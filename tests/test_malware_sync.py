"""Tests for the malware feed connector sync logic."""

from __future__ import annotations

from datetime import datetime, timezone
from unittest.mock import MagicMock, patch

from mimir.connectors.malware import (
    MalwareSyncResult,
    _iter_malware_docs,
    _parse_tags,
    _process_dailymalwarefeed_sample,
    _process_mwdb_sample,
    sync_malware_index,
)
from mimir.dedupe import EntityResolver
from tests.in_memory_graph_store import InMemoryGraphStore

# ── Fixtures ─────────────────────────────────────────────────


def _make_mwdb_doc(
    sha256: str = "a9a3cf0bfd7feb8c309fbb8e447b87301aa49527f36561caa6c5e328c77f6f18",
    file_name: str = "Set-up.exe",
    tags: list | None = None,
    attack_mappings: list | None = None,
    yara_rules: list | None = None,
    yara_tags: list | None = None,
    ips: list | None = None,
    urls: list | None = None,
    emails: list | None = None,
    has_high_entropy: bool = False,
) -> dict:
    """Build a realistic MWDB-OpenRelik document for testing."""
    if tags is None:
        tags = ["from:malwarebazaar", "family:santastealer"]
    if attack_mappings is None:
        attack_mappings = [
            {
                "tactic": "Defense Evasion",
                "technique": "Obfuscated Files or Information",
                "subtechnique": "Indicator Removal from Tools",
                "id": "T1027.005",
            },
            {
                "tactic": "Execution",
                "technique": "Shared Modules",
                "subtechnique": "",
                "id": "T1129",
            },
        ]

    capa_summary = {
        "rule_names": ["link function at runtime on Windows", "delay execution"],
        "attack_tactics": ["Defense Evasion", "Execution"],
        "attack_techniques": ["T1027", "T1027.005", "T1129"],
        "attack_mappings": attack_mappings,
        "mbc_mappings": [
            {
                "behavior": "Delay Execution",
                "objective": "Anti-Behavioral Analysis",
                "id": "B0003",
                "method": "",
            }
        ],
    }

    yara_summary: dict = {"rule_names": yara_rules or [], "tags": yara_tags or []}
    strings_summary: dict = {
        "ips": ips or [],
        "urls": urls or [],
        "emails": emails or [],
        "string_count": 1234,
    }
    entropy_summary: dict = {
        "has_high_entropy": has_high_entropy,
        "entropy_value": 7.8 if has_high_entropy else 5.2,
    }

    return {
        "@timestamp": "2026-02-04T23:43:05.784735+00:00",
        "_doc_id": sha256,
        "mwdb": {
            "sha256": sha256,
            "sha1": "955855dbcc1cc178c3cf0ac084de50948336859e",
            "md5": "b3f9e623d46d8c192139c9fc64a85c26",
            "crc32": "27dd4322",
            "ssdeep": "24576:Vo8xwcRppqOxpj:test",
            "file_name": file_name,
            "file_size": 9903548,
            "file_type": "PE32+ executable for MS Windows",
            "type": "file",
            "tags": tags,
            "upload_time": "2026-02-04T23:34:26.744393+00:00",
            "favorite": False,
            "share_3rd_party": True,
        },
        "sample": {
            "sha256": sha256,
            "filename": file_name,
            "mwdb_id": sha256,
        },
        "computed": {
            "imphash": "fcc736760ffc18b2096bf8dc1a972ac5",
            "compile_time": 1770152087,
            "entry_point": "0x13e0",
            "section_count": 10,
            "sections": [".text", ".data", ".rdata"],
        },
        "artifacts": {
            "Capa Malware Analysis": [
                {"name": "capa.json", "file_id": "1454", "summary": capa_summary}
            ],
            "Yara scan": [
                {"name": "yara.json", "file_id": "1455", "summary": yara_summary}
            ],
            "Strings": [
                {"name": "strings.json", "file_id": "1456", "summary": strings_summary}
            ],
            "High Entropy": [
                {"name": "entropy.json", "file_id": "1457", "summary": entropy_summary}
            ],
            "ExifTool Extractor": [
                {
                    "name": "exif.json",
                    "file_id": "1458",
                    "summary": {
                        "pdb_path": "C:\\dev\\malware\\main.pdb",
                        "company_name": "Evil Corp",
                        "original_filename": "loader.exe",
                        "machine_type": "AMD64",
                    },
                }
            ],
        },
    }


def _make_dailymalwarefeed_doc(
    sha256: str = "deadbeef" * 8,
    family: str = "emotet",
) -> dict:
    """Build a generic daily malware feed document."""
    return {
        "@timestamp": "2026-02-04T12:00:00+00:00",
        "_doc_id": sha256,
        "sha256": sha256,
        "md5": "abcdef1234567890abcdef1234567890",
        "sha1": "1234567890abcdef1234567890abcdef12345678",
        "file_name": "malware_sample.bin",
        "file_type": "PE32",
        "file_size": 123456,
        "malware_family": family,
        "tags": ["family:emotet", "from:virusshare"],
        "iocs": {
            "ips": ["10.0.0.1", "192.168.1.100"],
            "urls": ["http://c2-server.example.net/payload"],
            "domains": ["evil.example.com"],
            "emails": ["attacker@evil.example.com"],
        },
    }


# ── Tag parsing ──────────────────────────────────────────────


class TestParseTag:
    def test_family_tag(self):
        families, sources = _parse_tags(["family:santastealer"])
        assert families == ["santastealer"]
        assert sources == []

    def test_source_tag(self):
        families, sources = _parse_tags(["from:malwarebazaar"])
        assert families == []
        assert sources == ["malwarebazaar"]

    def test_mixed_tags(self):
        families, sources = _parse_tags(
            ["family:emotet", "from:virusshare", "family:trickbot"]
        )
        assert families == ["emotet", "trickbot"]
        assert sources == ["virusshare"]

    def test_empty_tags(self):
        families, sources = _parse_tags([])
        assert families == []
        assert sources == []

    def test_unknown_tags_ignored(self):
        families, sources = _parse_tags(["random-tag", "another"])
        assert families == []
        assert sources == []


# ── MWDB sample processing ──────────────────────────────────


class TestProcessMwdbSample:
    def _run(self, doc: dict | None = None) -> tuple:
        store = InMemoryGraphStore()
        resolver = EntityResolver(store)
        result = MalwareSyncResult()
        if doc is None:
            doc = _make_mwdb_doc()
        _process_mwdb_sample(doc, store, resolver, "test-run", result, "mwdb-openrelik")
        return store, result

    def test_creates_sample_entity(self):
        store, result = self._run()
        samples = [e for e in store.entities.values() if e.type == "malware_sample"]
        assert len(samples) == 1
        sample = samples[0]
        assert sample.attrs["sha256"].startswith("a9a3cf0b")
        assert sample.attrs["md5"] == "b3f9e623d46d8c192139c9fc64a85c26"
        assert sample.attrs["file_name"] == "Set-up.exe"
        assert sample.attrs["imphash"] == "fcc736760ffc18b2096bf8dc1a972ac5"

    def test_creates_malware_family_entity(self):
        store, result = self._run()
        families = [e for e in store.entities.values() if e.type == "malware"]
        family_names = {e.name.lower() for e in families}
        assert "santastealer" in family_names

    def test_creates_family_relation(self):
        store, result = self._run()
        variant_rels = [
            r for r in store.relations.values() if r.predicate == "variant_of"
        ]
        assert len(variant_rels) >= 1

    def test_creates_attack_pattern_entities(self):
        store, result = self._run()
        techniques = [e for e in store.entities.values() if e.type == "attack_pattern"]
        mitre_ids = {e.attrs.get("mitre_id") for e in techniques}
        assert "T1027.005" in mitre_ids
        assert "T1129" in mitre_ids

    def test_attack_patterns_are_keyed_by_mitre_id(self):
        doc = _make_mwdb_doc(
            attack_mappings=[
                {
                    "tactic": "Execution",
                    "technique": "Shared Modules",
                    "subtechnique": "",
                    "id": "t1129",
                },
                {
                    "tactic": "Execution",
                    "technique": "Different Label Same Technique",
                    "subtechnique": "",
                    "id": "T1129",
                },
            ]
        )
        store, result = self._run(doc)
        techniques = [
            e
            for e in store.entities.values()
            if e.type == "attack_pattern" and e.attrs.get("mitre_id") == "T1129"
        ]
        assert len(techniques) == 1

    def test_creates_attack_uses_relations(self):
        store, result = self._run()
        uses_rels = [r for r in store.relations.values() if r.predicate == "uses"]
        assert len(uses_rels) >= 2  # At least 2 ATT&CK techniques

    def test_creates_mbc_behavior_entities(self):
        store, result = self._run()
        mbc = [
            e
            for e in store.entities.values()
            if e.type == "capa_behavior" and "mbc_id" in e.attrs
        ]
        assert len(mbc) >= 1
        assert mbc[0].attrs["mbc_id"] == "B0003"
        assert mbc[0].attrs["behavior"] == "Delay Execution"

    def test_yara_rule_matches(self):
        doc = _make_mwdb_doc(yara_rules=["APT_Lazarus_Loader", "MALWARE_CobaltStrike"])
        store, result = self._run(doc)
        yara_entities = [e for e in store.entities.values() if e.type == "yara_rule"]
        assert len(yara_entities) == 2
        matches_rels = [r for r in store.relations.values() if r.predicate == "matches"]
        assert len(matches_rels) == 2

    def test_yara_tags(self):
        doc = _make_mwdb_doc(yara_tags=["ransomware", "trojan"])
        store, result = self._run(doc)
        detected_rels = [
            r for r in store.relations.values() if r.predicate == "detected_as"
        ]
        assert len(detected_rels) == 2

    def test_creates_capa_rule_entities(self):
        """Capa rule names are stored as pivotable capa_rule entities."""
        store, result = self._run()
        capa_rules = [e for e in store.entities.values() if e.type == "capa_rule"]
        rule_names = {e.attrs.get("rule_name") for e in capa_rules}
        assert "link function at runtime on Windows" in rule_names
        assert "delay execution" in rule_names
        assert len(capa_rules) == 2

    def test_capa_rule_has_mitre_ids(self):
        """Capa rule entities carry associated MITRE ATT&CK IDs."""
        store, result = self._run()
        capa_rules = [e for e in store.entities.values() if e.type == "capa_rule"]
        rules_with_mitre = [e for e in capa_rules if e.attrs.get("mitre_ids")]
        assert len(rules_with_mitre) >= 1
        # At least one rule should reference T1027.005 or T1129
        all_ids = set()
        for e in rules_with_mitre:
            all_ids.update(e.attrs["mitre_ids"])
        assert all_ids & {"T1027.005", "T1129"}

    def test_capa_rule_relations(self):
        """Samples are linked to Capa rules via exhibits_capability."""
        store, result = self._run()
        cap_rels = [
            r for r in store.relations.values() if r.predicate == "exhibits_capability"
        ]
        assert len(cap_rels) == 2

    def test_yara_rules_are_pivotable_by_type(self):
        """Yara rules have their own entity_type for direct pivoting."""
        doc = _make_mwdb_doc(yara_rules=["APT_Lazarus_Loader"])
        store, result = self._run(doc)
        # Should NOT show up as generic indicator
        generic_indicators = [
            e
            for e in store.entities.values()
            if e.type == "indicator" and e.attrs.get("indicator_type") == "yara_rule"
        ]
        assert len(generic_indicators) == 0
        # Should be explicit yara_rule type
        yara = [e for e in store.entities.values() if e.type == "yara_rule"]
        assert len(yara) == 1
        assert yara[0].attrs["rule_name"] == "APT_Lazarus_Loader"
        # Verify the match relation exists
        matches_rels = [r for r in store.relations.values() if r.predicate == "matches"]
        assert len(matches_rels) == 1

    def test_extracted_iocs_ips(self):
        doc = _make_mwdb_doc(ips=["10.0.0.1", "192.168.1.100"])
        store, result = self._run(doc)
        ip_entities = [
            e
            for e in store.entities.values()
            if e.type == "indicator" and e.attrs.get("indicator_type") == "ip"
        ]
        assert len(ip_entities) == 2

    def test_extracted_iocs_urls(self):
        doc = _make_mwdb_doc(urls=["http://evil.com/payload"])
        store, result = self._run(doc)
        url_entities = [
            e
            for e in store.entities.values()
            if e.type == "indicator" and e.attrs.get("indicator_type") == "url"
        ]
        assert len(url_entities) == 1

    def test_extracted_iocs_emails(self):
        doc = _make_mwdb_doc(emails=["attacker@evil.com"])
        store, result = self._run(doc)
        email_entities = [
            e
            for e in store.entities.values()
            if e.type == "indicator" and e.attrs.get("indicator_type") == "email"
        ]
        assert len(email_entities) == 1

    def test_exiftool_metadata(self):
        store, result = self._run()
        samples = [e for e in store.entities.values() if e.type == "malware_sample"]
        sample = samples[0]
        assert sample.attrs.get("pdb_path") == "C:\\dev\\malware\\main.pdb"
        assert sample.attrs.get("company_name") == "Evil Corp"
        assert sample.attrs.get("original_filename") == "loader.exe"
        assert sample.attrs.get("pe_arch") == "AMD64"

    def test_high_entropy(self):
        doc = _make_mwdb_doc(has_high_entropy=True)
        store, result = self._run(doc)
        samples = [e for e in store.entities.values() if e.type == "malware_sample"]
        sample = samples[0]
        assert sample.attrs.get("has_high_entropy") is True
        assert sample.attrs.get("entropy_value") == 7.8

    def test_source_attribution(self):
        store, result = self._run()
        identities = [e for e in store.entities.values() if e.type == "identity"]
        identity_names = {e.name.lower() for e in identities}
        assert "malwarebazaar" in identity_names

    def test_cross_links_family_to_techniques(self):
        store, result = self._run()
        # Family entity should have "uses" relations to ATT&CK techniques
        malware_entities = [e for e in store.entities.values() if e.type == "malware"]
        assert len(malware_entities) >= 1

        family_id = malware_entities[0].id
        family_uses = [
            r
            for r in store.relations.values()
            if r.subject_id == family_id and r.predicate == "uses"
        ]
        assert len(family_uses) >= 1

    def test_skips_no_sha256(self):
        doc = _make_mwdb_doc()
        doc["mwdb"]["sha256"] = ""
        doc["sample"]["sha256"] = ""
        store, result = self._run(doc)
        assert result.samples_processed == 0

    def test_provenance_attached(self):
        store, result = self._run()
        # Every relation should have provenance
        for rel_id in store.relations:
            prov_ids = store.provenance_by_relation.get(rel_id, [])
            assert len(prov_ids) >= 1, f"Relation {rel_id} has no provenance"

    def test_counts(self):
        store, result = self._run()
        assert result.samples_processed == 1
        assert result.entities_created > 0
        assert result.relations_created > 0


# ── Daily Malware Feed processing ────────────────────────────


class TestProcessDailyMalwareFeed:
    def _run(self, doc: dict | None = None) -> tuple:
        store = InMemoryGraphStore()
        resolver = EntityResolver(store)
        result = MalwareSyncResult()
        if doc is None:
            doc = _make_dailymalwarefeed_doc()
        _process_dailymalwarefeed_sample(
            doc, store, resolver, "test-run", result, "dailymalwarefeed"
        )
        return store, result

    def test_creates_sample_entity(self):
        store, result = self._run()
        samples = [e for e in store.entities.values() if e.type == "malware_sample"]
        assert len(samples) == 1
        assert samples[0].attrs["file_name"] == "malware_sample.bin"

    def test_creates_family_entity(self):
        store, result = self._run()
        families = [e for e in store.entities.values() if e.type == "malware"]
        family_names = {e.name.lower() for e in families}
        assert "emotet" in family_names

    def test_ioc_extraction(self):
        store, result = self._run()
        indicators = [e for e in store.entities.values() if e.type == "indicator"]
        indicator_types = {e.attrs.get("indicator_type") for e in indicators}
        assert "ip" in indicator_types
        assert "url" in indicator_types
        assert "domain" in indicator_types
        assert "email" in indicator_types

    def test_communicates_with_relations(self):
        store, result = self._run()
        comm_rels = [
            r for r in store.relations.values() if r.predicate == "communicates_with"
        ]
        assert len(comm_rels) >= 4  # 2 IPs + 1 URL + 1 domain + 1 email = 5

    def test_family_from_tags(self):
        store, result = self._run()
        variant_rels = [
            r for r in store.relations.values() if r.predicate == "variant_of"
        ]
        # One from malware_family field + one from family:emotet tag
        # (same family, so may dedupe)
        assert len(variant_rels) >= 1

    def test_source_from_tags(self):
        store, result = self._run()
        identities = [e for e in store.entities.values() if e.type == "identity"]
        identity_names = {e.name.lower() for e in identities}
        assert "virusshare" in identity_names
        attributed_rels = [
            r for r in store.relations.values() if r.predicate == "attributed_to"
        ]
        assert len(attributed_rels) >= 1

    def test_falls_back_to_mwdb_handler(self):
        """If a dailymalwarefeed doc has an 'mwdb' key, use MWDB handler."""
        doc = _make_mwdb_doc()
        store, result = self._run(doc)
        # Should still produce a sample entity via the MWDB handler
        samples = [e for e in store.entities.values() if e.type == "malware_sample"]
        assert len(samples) == 1

    def test_skips_no_hash(self):
        doc = {"@timestamp": "2026-01-01T00:00:00+00:00", "_doc_id": "x"}
        store, result = self._run(doc)
        assert result.samples_processed == 0

    def test_hash_upgrade_reuses_existing_sample_entity(self):
        store = InMemoryGraphStore()
        resolver = EntityResolver(store)
        result = MalwareSyncResult()

        md5_only = {
            "@timestamp": "2026-02-04T10:00:00+00:00",
            "_doc_id": "sample-1",
            "md5": "abcdef1234567890abcdef1234567890",
            "sha1": "1234567890abcdef1234567890abcdef12345678",
            "file_name": "malware_sample.bin",
        }
        with_sha256 = {
            "@timestamp": "2026-02-04T10:05:00+00:00",
            "_doc_id": "sample-1-updated",
            "sha256": "deadbeef" * 8,
            "md5": "abcdef1234567890abcdef1234567890",
            "sha1": "1234567890abcdef1234567890abcdef12345678",
            "file_name": "malware_sample.bin",
        }

        _process_dailymalwarefeed_sample(
            md5_only,
            store,
            resolver,
            "test-run",
            result,
            "dailymalwarefeed",
        )
        _process_dailymalwarefeed_sample(
            with_sha256,
            store,
            resolver,
            "test-run",
            result,
            "dailymalwarefeed",
        )

        samples = [e for e in store.entities.values() if e.type == "malware_sample"]
        assert len(samples) == 1
        sample = samples[0]
        assert sample.name == "deadbeef" * 8
        assert sample.attrs.get("sha256") == "deadbeef" * 8
        assert sample.attrs.get("md5") == "abcdef1234567890abcdef1234567890"


class TestMalwareSyncIndex:
    def test_iter_query_supports_multiple_timestamp_fields(self):
        client = MagicMock()
        client.search.return_value = {"hits": {"hits": []}}
        settings = MagicMock()
        settings.elastic_connector_page_size = 100

        since = datetime(2026, 2, 1, tzinfo=timezone.utc)
        docs = list(
            _iter_malware_docs(
                client,
                "mwdb-openrelik",
                since,
                settings,
                max_docs=10,
            )
        )
        assert docs == []

        kwargs = client.search.call_args.kwargs
        assert kwargs["index"] == "mwdb-openrelik"
        ranges = kwargs["query"]["bool"]["should"]
        fields = {next(iter(item["range"].keys())) for item in ranges}
        assert "@timestamp" in fields
        assert "mwdb.upload_time" in fields
        assert kwargs["query"]["bool"]["minimum_should_match"] == 1
        assert kwargs["sort"][0]["@timestamp"]["unmapped_type"] == "date"
        assert kwargs["sort"][1]["mwdb.upload_time"]["unmapped_type"] == "date"

    def test_sync_skips_missing_index(self):
        store = InMemoryGraphStore()
        settings = MagicMock()
        settings.malware_worker_lookback_minutes = 180
        settings.malware_worker_max_per_index = 500

        client = MagicMock()
        client.indices.exists.return_value = False

        with patch(
            "mimir.connectors.malware._create_source_client", return_value=client
        ):
            result = sync_malware_index(
                settings=settings,
                graph_store=store,
                index_name="mwdb-openrelik",
                since=datetime(2026, 2, 1, tzinfo=timezone.utc),
            )

        assert result.indexes_scanned == 0
        assert result.samples_processed == 0
        assert result.entities_created == 0
        assert result.relations_created == 0
        client.close.assert_called_once()

    def test_sync_sets_indexes_scanned_when_index_exists(self):
        store = InMemoryGraphStore()
        settings = MagicMock()
        settings.malware_worker_lookback_minutes = 180
        settings.malware_worker_max_per_index = 500

        client = MagicMock()
        client.indices.exists.return_value = True

        with patch(
            "mimir.connectors.malware._create_source_client", return_value=client
        ):
            with patch(
                "mimir.connectors.malware._iter_malware_docs",
                return_value=iter(()),
            ):
                result = sync_malware_index(
                    settings=settings,
                    graph_store=store,
                    index_name="mwdb-openrelik",
                    since=datetime(2026, 2, 1, tzinfo=timezone.utc),
                )

        assert result.indexes_scanned == 1
        client.close.assert_called_once()
