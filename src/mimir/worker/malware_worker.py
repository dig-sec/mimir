"""Malware feed connector worker.

Standalone worker process that periodically syncs malware sample data
from Elasticsearch indices (``mwdb-openrelik``, ``dailymalwarefeed``)
into the Mimir knowledge graph.

The worker:
* Runs on its own schedule (``MALWARE_WORKER_INTERVAL_MINUTES``, default 30)
* Uses a lookback window (``MALWARE_WORKER_LOOKBACK_MINUTES``) to catch
  missed samples
* Directly extracts structured entities (hashes, families, ATT&CK
  techniques, IOCs, Yara rules) without LLM processing
* Gracefully shuts down on SIGINT/SIGTERM
"""

from __future__ import annotations

import asyncio
import logging
import signal
from datetime import datetime, timedelta, timezone

from ..config import get_settings
from ..connectors.malware import sync_malware_index
from ..storage.factory import create_graph_store
from .heartbeat import WorkerHeartbeat

logger = logging.getLogger(__name__)

_shutdown = asyncio.Event()


def _handle_signal() -> None:
    logger.info("Malware worker: shutdown signal received")
    _shutdown.set()


def _install_signal_handlers(loop: asyncio.AbstractEventLoop) -> None:
    """Install shutdown handlers with a portable fallback."""
    for sig in (signal.SIGINT, signal.SIGTERM):
        try:
            loop.add_signal_handler(sig, _handle_signal)
        except (NotImplementedError, RuntimeError, ValueError):
            try:
                signal.signal(sig, lambda *_: _handle_signal())
            except (ValueError, OSError):
                logger.warning(
                    "Malware worker: unable to install signal handler for %s",
                    sig.name,
                )


async def malware_worker_loop() -> None:
    """Periodically sync malware samples from Elasticsearch."""
    settings = get_settings()
    heartbeat = WorkerHeartbeat(settings, "malware-worker")
    logging.basicConfig(level=settings.log_level)
    _shutdown.clear()

    if not settings.malware_worker_enabled:
        logger.info("Malware worker: disabled (MALWARE_WORKER_ENABLED=0). Exiting.")
        heartbeat.update("disabled", {"reason": "MALWARE_WORKER_ENABLED=0"})
        return

    if not settings.elastic_connector_enabled:
        logger.info(
            "Malware worker: disabled (ELASTIC_CONNECTOR_ENABLED=0). Exiting."
        )
        heartbeat.update("disabled", {"reason": "ELASTIC_CONNECTOR_ENABLED=0"})
        return

    if not settings.elastic_connector_hosts_list:
        logger.warning("Malware worker: no connector hosts configured. Exiting.")
        heartbeat.update("disabled", {"reason": "no connector hosts configured"})
        return

    interval_minutes = settings.malware_worker_interval_minutes
    interval = interval_minutes * 60
    if interval <= 0:
        logger.info(
            "Malware worker: disabled (MALWARE_WORKER_INTERVAL_MINUTES=%d). Exiting.",
            interval_minutes,
        )
        heartbeat.update(
            "disabled",
            {
                "reason": "MALWARE_WORKER_INTERVAL_MINUTES<=0",
                "interval_minutes": interval_minutes,
            },
        )
        return

    indices = settings.malware_worker_indices_list
    if not indices:
        logger.info("Malware worker: no indices configured. Exiting.")
        heartbeat.update("disabled", {"reason": "no malware indices configured"})
        return

    lookback_minutes = max(settings.malware_worker_lookback_minutes, 0)
    graph_store = create_graph_store(settings)

    loop = asyncio.get_running_loop()
    _install_signal_handlers(loop)

    logger.info(
        "Malware worker started â€” interval=%dm, lookback=%dm, indices=%s",
        interval_minutes,
        lookback_minutes,
        indices,
    )
    heartbeat.update(
        "running",
        {
            "interval_minutes": interval_minutes,
            "lookback_minutes": lookback_minutes,
            "indices": indices,
        },
    )

    while not _shutdown.is_set():
        cycle_end = datetime.now(timezone.utc)
        since = cycle_end - timedelta(minutes=lookback_minutes)
        cycle_failed_indices: list[str] = []
        heartbeat.update(
            "running",
            {
                "cycle_started_at": cycle_end.isoformat(),
                "since": since.isoformat(),
                "indices": indices,
            },
        )

        for index_name in indices:
            if _shutdown.is_set():
                break
            try:
                result = await asyncio.to_thread(
                    sync_malware_index,
                    settings=settings,
                    graph_store=graph_store,
                    index_name=index_name,
                    since=since,
                    until=cycle_end,
                    max_docs=settings.malware_worker_max_per_index,
                )
                logger.info(
                    "Malware sync %s: %d samples, %d entities, %d relations",
                    index_name,
                    result.samples_processed,
                    result.entities_created,
                    result.relations_created,
                )
                heartbeat.update(
                    "running",
                    {
                        "last_index": index_name,
                        "cycle_started_at": cycle_end.isoformat(),
                        "samples_processed": result.samples_processed,
                        "entities_created": result.entities_created,
                        "relations_created": result.relations_created,
                        "errors": len(result.errors),
                    },
                )
                if result.errors:
                    for err in result.errors[:5]:
                        logger.warning("Malware sync error: %s", err)
            except Exception:
                logger.exception("Malware sync failed for index %s", index_name)
                cycle_failed_indices.append(index_name)
                heartbeat.update(
                    "error",
                    {"last_index": index_name, "cycle_started_at": cycle_end.isoformat()},
                )

        # Wait for next cycle or shutdown
        try:
            if cycle_failed_indices:
                heartbeat.update(
                    "error",
                    {
                        "cycle_started_at": cycle_end.isoformat(),
                        "failed_indices": cycle_failed_indices[:10],
                        "next_run_in_seconds": interval,
                    },
                )
            else:
                heartbeat.update(
                    "sleeping", {"next_run_in_seconds": interval, "indices": indices}
                )
            await asyncio.wait_for(_shutdown.wait(), timeout=interval)
            break
        except asyncio.TimeoutError:
            pass

    logger.info("Malware worker stopped")
    heartbeat.update("stopped")


def main() -> None:
    asyncio.run(malware_worker_loop())


if __name__ == "__main__":
    main()
